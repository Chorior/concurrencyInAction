---
title:      "C++ 多线程"
subtitle:   "concurrency in action"
date:       2017-04-24 20:20:00 +0800
header-img: "img/stock-photo-4.jpg"
tags:
    - C++
    - thread
---

本文知识来自[C++ Concurrency In Action](https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/)，介绍有关C++11多线程(multithreading)相关的知识。

#   本文结构

*   [多线程概述](#multithreading_overview)


<h2 id="multithreading_overview">多线程概述</h2>

#### 基本概念

并发：**同一时间内发生两个或更多独立的活动**；

任务切换: 每个任务交织进行,但切换会有时间开销；

硬件并发(hardware concurrency): 真正的并行多个任务。

**即便是具有真正硬件并发的系统，有时候也会需要任务切换**；

#### 使用并发的两种方法

将应用程序分为多个独立的进程,它们在同一时刻运行

*   缺点

    *   进程间通信设置复杂，速度慢，因为系统在进程间提供了很多保护措施用以保护数据；
    *   运行多个进程需要固定开销：需要时间启动进程，操作系统需要内部资源来管理进程，等等；

*   优点

    *   更容易编写安全(safe)的并发代码；
    *   可以使用远程连接(可能需要联网)，在不同的机器上运行独立的进程；

在单个进程中运行多个线程

*   缺点

    *   进程中的所有线程都共享地址空间；        
    *   如果数据要被多个线程访问，那么必须确保每个线程所访问到的数据是一致的；

*   优点

    *   使用多线程相关的开销远远小于使用多个进程；
    *   全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。

**C++标准并未对进程间通信提供任何原生支持**。

#### 使用并发的两种原因

分离关注点(separation of concerns(SOC))

*   将相关的代码与无关的代码分离，使程序更容易理解和测试，减少出错的可能性；
*   独立的线程通常用来执行那些必须在后台持续运行的任务，如socket服务器。

提升性能

*   任务并行(task parallelism)：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间；
*   数据并行(data parallelism)：同时对多组数据执行相同的操作。

#### 并发的缺点

*   如果在线程上的任务完成得很快，那么任务实际执行的时间要比启动线程的时间小很多；
*   运行太多的线程会耗尽进程的可用内存或地址空间(**可以使用线程池来限定线程数量**)；
*   线程数越多，操作系统就需要做越多的上下文切换；
*   **使用并发可能使代码复杂化、更难理解，并且更容易出错**。

**当并发收益小于实际开发和维护的成本时，不要使用并发**。

**在绝大多数情况下，额外增加的复杂性和出错几率都远大于性能的小幅提升带来的收益**。

#### Hello, world

```c++
#include <iostream>
#include <thread>

void hello() { 
    std::cout << "Hello Concurrent World!\n"; 
}

int main()
{
    std::thread t(hello);
    t.join();
}
```

*   g++编译时须加上`-pthread -std=c++11`；
*   管理线程的函数和类在`<thread>`中声明，而保护共享数据的函数和类在其他头文件中声明；
*   初始线程始于`main()`，新线程始于`hello()`；
*   `join()`使得初始线程等待新线程结束后，才能运行下面的语句或结束自己的线程；
*   该示例使用多线程并没有带来任何收益；
*   **使用多线程并不复杂，复杂的是如何设计代码以实现其预期的行为**。
